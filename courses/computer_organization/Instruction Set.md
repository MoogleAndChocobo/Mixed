# 指令系统(Instruction Set)

## 指令系统的设计(Instruction Set Design)

1. 指令系统处于软/硬件交互界面,同时被硬件设计者和系统程序员所看到
    - 硬件设计者角度:指令系统为CPU提供功能需求,要求易于硬件设计
    - 系统程序员角度:通过指令系统使用硬件,要求易于编写编译器
    - 指令系统的好坏决定了计算机的性能和成本
        > 冯诺伊曼结构机器对指令的规定
        >
        > 1. 用二进制表示,和数据一起存放在主存中
        > 2. 由两部分组成:操作码和操作数/地址码
        >     - Opeation Code: defines the operation type
        >     - Operands: indicate operation source and destination

2. 一条指令必须<font color='red'>明显</font>或<font color='red'>隐含</font>包含的信息有哪些?
        1. 操作码:指定操作类型
            `操作码长度:固定/可变`
        2. 源操作数参照:一个或多个源操作数所在的地址
            `操作数来源:主(虚)存/寄存器/IO端口/指令本身`
        3. 结果值参照:产生的结果存放在何处(目的操作数)
            `结果地址:主(虚)存/寄存器/IO端口`
        4. 下一条指令地址:下条指令存放在何处(正常情况隐含在PC中,改变顺序时由指令指出)
            `下条指令地址:主(虚)存`

3. 一条指令中应该有几个地址码字段?
    1. 零地址指令
       1. 无需操作数 `如:空操作,停机`
       2. 所需操作数默认 `如:堆栈,累加器`
            形式: `OP`
    2. 一地址指令
        其地址既是操作数的指令,也是结果的地址
        1. 单目运算 `如:取反,取负`
        2. 双目运算 `如:累加器`
            形式: `OP | A1`
    3. 二地址指令(<font color='red'>最常用</font>)
        分别存放双目运算中两个操作,并将其中一个地址作为结果的地址
            形式: `OP | A1 | A2`
    4. 三地址指令(<font color='red'>RISC风格</font>)
        分别作为双目运算中两个源操作数的地址和一个结果的地址
            形式: `OP | A1 | A2 | A3`
    5. 多地址指令
        大中型机中用于成批数据处理的指令 `如:向量,矩阵`

4. 从指令执行周期看指令设计涉及的问题

### 指令系统设计的基本原则

1. 尽量短
2. 有足够的操作码位数
3. 指令编码有唯一的解释,否则不合法
4. 指令字长为字节的的整数倍
5. 合理选择地址字段的个数
6. 指令尽量规整

    > 与指令集设计相关的重要方面
    >     - 操作码的全部组成:操作码个数/种类/复杂度
    >     - 数据类型
    >     - 指令格式:指令长度/地址码个数/各字段长度
    >     - 通用寄存器:个数/功能/长度
    >     - 寻址方式:操作数地址的指定方式
    >     - 下条指令的地址如何确定:顺序/PC+1/条件转转移/无条件转移/...
    >     <font colot='red'>一般通过对操作码进行不同的编码定义不同含义,操作码相同时,再通过功能码定义不同含义</font>

### 指令类型和格式

典型常用操作(Typical Operations)

> Data Movement(传送)
> Input/Output(输入/输出)
> Arithmetic(算术)
> Logical(逻辑)
> Shift(移位)
> String(字符串)
> Exec-Seq control(转移控制)
> CPU control
> Subroutine Linkage(调用)
> Interrupt(终端)
> Synchronization(信号同步)

### 数据类型

1. 地址:看作无符号整数参加运算,用于确定主(虚)存地址
2. 数值数据
   - 定点数:一般用二进制补码表示
   - 浮点数:一般采用IEEE754标准
   - 十进制数:一般用NBCD码表示,压缩/非非压缩
3. 位/位串/字符/字符串:表示文本,声音和图像等
4. 逻辑(布尔)数据

### 操作数的寻址方式(Addressing Mode)

1. 寻址方式定义
    指令或操作数地址的指定方式,即:根据地址找到指令或操作数的方法
2. 地址码
    地址码编码由操作数的寻址方式决定
    地址码编码原则
    - 尽量短
    - 操作数存放位置灵活,空间尽量大(<font color='red'>利于编译器优化</font>)
    - 地址计算过程简单
3. 通常寻址方式指<font color='red'>"操作数的寻址</font>
4. 寻址方式的确定
    - 没有专门的寻址方式位(由操作码确定寻址方式) `如:MIPS指令,一条指令中最多仅有一个主(虚)存地址,且仅有一到两种寻址方式`
    - 由专门的寻址方式 `如:X86指令,一条指令中由多个操作数,且寻址方式各不相同`
5. 有效地址的含义
    操作数所在存储单元的地址(逻辑/物理地址),可通过指令的寻址方式和地址码得到
6. 基本寻址方式
假设A=地址字段值,R=寄存器编号,EA=有效地址,(X)=X中的内容 `OP | R | A | .etc`
|方式|算法|主要优点|主要缺点|
|:---:|:---:|:---:|:---:|
|立即|操作数=A|指令执行速度快|操作数幅值有限|
|直接|EA=A|有效地址计算简单|地址范围有限|
|间接|EA=(A)|有效地址范围大|多次存储器访问|
|寄存器|操作数=(R)|指令执行快,指令短|地址范围有限|
|寄间接|EA=(R)|地址范围大|额外存储器访问|
|偏移|EA=A+(R)|灵活 复杂||
|堆栈|EA=栈顶|指令短|应用有限|
偏移方式:将直接方式和寄存器间接方式结合起来,有相对/基址/变址
7. 偏移寻址方式
    - 相对寻址 `EA=(PC)+A`
    - 基址寻址 `EA=(B)+A`
    - 变址寻址 `EA=(I)+A`

### 操作码的编码

#### 定长编码法(Fixed Length Opcodes)

1. 基本思想
    指令的操作码部分采用固定长度的编码
    `如:假设操作码固定为6位,则系统最多可表示64种指令`
2. 特点
    译码方便,但有信息冗余
3. 举例
    IBM360/370采用8位定长操作码,但只提供了183种指令

#### 变长/扩展编码法(Expanding Opcodes)

1. 基本思想
    将操作码的编码长度分成几种固定长的格式,被大多数指令集采用
2. 种类:等长扩展/补等长扩展

### 条件码和标志寄存器

### 指令设计风格

#### 按操作数位置指定风格分类

1. Accumulator(累加器型):其中一个操作数和目的操作数总在累加器中
2. Stack(堆栈型):总是将栈顶两个操作数进行运算,无需指定操作数地址
3. General Purpose Register(通用寄存器型):操作数可以是寄存器或存储器数据
4. Load/Store(装入/存储型):操作数只能是寄存器数据

#### 按指令格式复杂度分类

1. CISC(Complex Instruction Set Computer,复杂指令集计算机)
    主要特点
        1. 指令系统复杂
        2. 指令周期长
        3. 各种指令都能访问寄存器
        4. 采用微程序控制
        5. 有专用寄存器
        6. 难以进行编译优化生成高效目标代码
2. RISC(Reduce Instruction Set Computer,精简指令集计算机)
    主要特点
        1. 指令系统简单
        2. 指令周期短
        3. 以R/R方式工作,除L/S指令可访问存储器外,其余指令都只访问寄存器
        4. 采用大量通用寄存器减少访问次数
        5. 采用组合逻辑电路控制,不用或少用微程序控制
        6. 采用优化的编译系统,有效支持高级语言程序

### 指令系统举例

## 程序的机器级表示
